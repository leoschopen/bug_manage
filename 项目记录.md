# sass平台

SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统

# 知识点concerning

- 虚拟环境，多个python环境

  ```
  py3：
  	django 1.11 ->crm系统
  	django 2.0 ->路飞
  需要虚拟环境
  django/pymysql/sms(短信)/redis/celery
  虚拟1，虚拟2
  ```

  ```
  //local_setting.py本地配置
  开发和测试需要变换ip等对数据库配置等需要变动，要在localsetting本地配置中修改省事，统一配置而非每个文件中写
  try：
  except：
  databases：
  /除了localsetting以外的给测试
  ```

- 腾讯云平台

  - sms短信

  - cos对象存储，腾讯给云硬盘，项目中上传文件、查看文件、下载文件

    >使用自己的电脑速度慢，通过对象存储将压力交给腾讯云对象存储

- redis

  ```
  mysql
   自己                  另外的电脑
   pymysql          -》mysql软件-》行为（硬盘文件操作crud）
   
   mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。
  redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。
   本质区别是mysql是对硬盘文件操作，redis是对内存的操作，redis速度更快
   
   redis
   自己                  另外
   pymysql         -》   redis软件-》（
                                     set name = “s”在内存中创造
                                     get name 在内存中获取
                                     可以对数据进行超时时间进行过期处理
  ```

  # 开发安排

  - 一期：用户认证（短信，验证码，django modelform）
  - 二期：wiki，文件，问题
  - 三期：支付，部署，linux

# day01

1.虚拟环境

- 使用virtualenv

  ```
  pip3 install virtualenv
  
  创建：virtualenv name （--python=python3.7.8//需要配置环境变量）
  会创建一个文件夹包含此环境
  
  激活：scripts目录
  activate.exe
  ```

2，配置local_settings

## git

```
Microsoft Windows [版本 10.0.18363.1556]
(c) 2019 Microsoft Corporation。保留所有权利。
//本地初始化
(bug_manage) D:\PyProject\bug_manage>git init
Initialized empty Git repository in D:/PyProject/bug_manage/.git/
//选中所有
(bug_manage) D:\PyProject\bug_manage>git add .
//命名
(bug_manage) D:\PyProject\bug_manage>git commit -m '第一次提交'

//起别名
(bug_manage) D:\PyProject\bug_manage>git remote add origin https://github.com/leoschopen/bug_manage.git
//push
(bug_manage) D:\PyProject\bug_manage>git push origin master


```

# day02

## abstract

- 腾讯sms
- django的ModelForm组件
- redis
- 注册逻辑设计

## 虚拟环境搭配模块版本描述

pip freeze > requirements.txt

pip install -r requirements.txt

## git的一个错误

```
To https://github.com/leoschopen/bug_manage.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'https://github.com/leoschopen/bug_manage.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
分析：
可能是手动在github创建了readme，我们在关联本地与远程时，两端都是有内容的，但是这两份内容并没有联系，当我们推送到远程或者从远程拉取内容时，都会有没有被跟踪的内容，于是你看git报的详细错误中总是会让你先拉取再推送，但是拉取总是失败。
解决：对于error: failed to push some refs to‘远程仓库地址’
1 使用如下命令
git pull --rebase origin master

2 然后再进行上传:

git push -u origin master
```

## doubts

- httpresponse的原理
- django的有关传输和操作不熟悉。感觉和servlet有点像，但是servlet也忘记完了
- ajax的过程

## ModelForm

- 使用modelform生成页面上的一些基本字段

- 自动生成标签

```python
#models.py
from django.db import models

# Create your models here.
class UserInfo(models.Model):
    username= models.CharField(verbose_name='用户名',max_length=32)
    email = models.EmailField(verbose_name='邮箱',max_length=32)
    mobile_phone = models.CharField(verbose_name='手机号',max_length=32)
    password = models.CharField(verbose_name='密码',max_length=32)
   
#views.py
from django import forms
from app01 import models
from django.core.validators import RegexValidator

class RegisterModelForm(forms.ModelForm):
    """如果原来的modelform原来定义得有，重复则重写，否则添加"""
    #手机号验证
    mobile_phone = forms.CharField(
        label='手机号',
        validators=[RegexValidator(r'^(1[3|4|5|6|7|8|9])\d{9}$','手机号格式错误'),])#正则表达式
    #密码密文展示,并确定标签的属性
    password = forms.CharField(
        label='密码',
        widget=forms.PasswordInput())
    #重复输入密码
    confirm_password = forms.CharField(
        label='重复密码',
        widget=forms.PasswordInput())
    #验证码
    code = forms.CharField(
        label='验证码',
        widget=forms.TextInput())
    class Meta:
        model = models.UserInfo
        fields = "__all__"
    #重写init函数每个标签的class都设置为form—control
    def __init__(self,*args,**kwargs):
        super().__init__(*args,**kwargs)
        for name,field in self.fields.items():
            field.widget.attrs['class'] = 'form-control'
            field.widget.attrs['placeholder'] = '请输入%s' % field.label

def register(request):
    form = RegisterModelForm()
    return render(request,'register.html',{'form':form})
    
```

## 使用bootstrap写前端的页面

```
 #循环生成
 {% for field in form %}
      <div class="form-group">
            <label for="{{ field.id_for_label }}">{{ field.label }}</label>
              {% comment %}<input type="email" class="form-control" id="exampleInputEmail"     placeholder="Email">{% endcomment %}
               {{ field }}
              </div>
                {% endfor %}
                
#重写init函数为组件添加默认class和有关属性
```

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220107233215300.png" alt="image-20220107233215300" style="zoom:33%;" />

- 形状不对齐

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220107234614031.png" alt="image-20220107234614031" style="zoom:50%;" />

解决方法padding-left

```html
<div class="col-md-6" style="padding-left: 0;">{{ field }}</div> 
```

- 将页面注册字段的顺序进行调整

  > 默认是根据modelform的顺序加上后续添加的顺序

  解决方法：

  ```
     class Meta:
          model = models.UserInfo
          fields = "__all__"   
     class Meta:
          model = models.UserInfo
          fields = ['username','email','password','confirm_password','mobile_phone','code']
  ```

  

## 验证码实现

- 获取手机号

- 后台发ajax

  - 参数：号码，tpl=register

- 向手机发短信

  - 验证码的时效的处理60s

  - 书局存储在redis上

    ![image-20220108000730304](https://gitee.com/leoschopen/picture/raw/master/null/image-20220108000730304.png)

1. 我调api发给腾讯（申请验证码过程）
2. 腾讯发给用户
3. 同时我把验证码放在redis中，设置失效时间并验证（注册按钮）



# day03

- 任务
  - modelform页面
  - ajax请求，向后台传手机号和tql
  - sms+redis
  - 字段校验，验证码校验
  - 倒计时效果

## 安装第三方库 Non-zero exit code(2)报错

解决方法：

- pip install --upgrade pip升级pip（失效）
- pip install redis -i https://pypi.tuna.tsinghua.edu.cn/simple（使用第三方库）（成功）
-   阿里云 http://mirrors.aliyun.com/pypi/simple
      中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple
      豆瓣(douban) http://pypi.douban.com/simple
      清华大学 https://pypi.tuna.tsinghua.edu.cn/simple
      中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple
- <img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220108105745499.png" alt="image-20220108105745499" style="zoom:50%;" />

发现添加数据源之后已然不能再仓库中搜索下载，还是使用命令吧

使用国内镜像又报错

Cannot determine archive format of C:\Users\ZYZYLE~1\AppData\Local\Temp\pip-req-build-62t0iy4y

```
pip install -i http://pypi.douban.com/simple/ --trusted-host=pypi.douban.com/simple django-ckeditor
```



# day04

- 补坑

## css补充

- ### 样式的优先级：标签高于头部高于文件

- ### 选择器：

  ```
  标签选择
  span {
         color: red;
  }
  
  
  ### ID 选择器：规定用`#`来定义
  针对某一个特定的标签来使用，只能使用一次。css 中的 ID 选择器以”#”来定义。
  #mytitle{ border:3px dashed green; }
     
     
  ### 类选择器：规定用圆点`.`来定义针对**你想要的所有**标签使用。优点：灵活。
  css 中用`.`来表示类。举例如下：
  .one{ width:800px; }
  
  
  后代选择器
   div div p {
                  color: red;
  }
   <div class="div3">
        <div class="div4">
              <p>我是什么颜色？</p>
        </div>
  </div>
  
  
  
  交集选择器
  h3.special {
      color: red;
  }
          <h3 class="special zhongyao">标题1</h3>
          <h3 class="special">我也是标题</h3>
          
         
  并集选择器 ：定义的时候用逗号隔开 
  p,
  h1,
  #mytitle,
  .one {
      color: red;
  }
  
  子代选择器
  div > p {
      color: red;
  }
  <div>
      <p>我是div的儿子</p>
  </div>
  
  序选择器
      ul li:first-child {
          color: red;
      }
      <ul>
      <li class="first">项目</li>
      <li>项目</li>
      <li>项目</li>
      
      
  下一个兄弟选择器 `+`表示选择下一个兄弟   
  选择的是 h3 元素后面紧挨着的第一个兄弟。    
  
  ```

  <img src="https://gitee.com/leoschopen/picture/raw/master/null/20170711_1950.png" style="zoom:67%;" />

### 行级元素与块级元素

行内元素：

- 与其他行内元素并排；
- 不能设置宽、高。默认的宽度，就是文字的宽度。

块级元素：

- 霸占一行，不能与其他任何元素并列；
- 能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。

<img src="https://gitee.com/leoschopen/picture/raw/master/null/20170729_1532_2.png" style="zoom:67%;" />

<img src="https://gitee.com/leoschopen/picture/raw/master/null/20170729_1545.png" style="zoom:67%;" />

### 行内元素和块级元素的相互转换

#### 块级元素可以转换为行内元素：

一旦，给一个块级元素（比如div）设置：

```
display: inline;
```

那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说：

- 此时这个div不能设置宽度、高度；
- 此时这个div可以和别人并排了。

<img src="https://gitee.com/leoschopen/picture/raw/master/null/20170729_1629.png" style="zoom:67%;" />

#### 行内元素转换为块级元素：

同样的道理，一旦给一个行内元素（比如span）设置：

```
display: block;
```

那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说：

- 此时这个span能够设置宽度、高度
- 此时这个span必须霸占一行了，别人无法和他并排
- 如果不设置宽度，将撑满父亲

举例如下：

![](https://gitee.com/leoschopen/picture/raw/master/null/20170729_1638.png)

标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：移民！**脱离标准流**！


css中一共有三种手段，使一个元素脱离标准文档流：

- （1）浮动
- （2）绝对定位
- （3）固定定位

- 所有标签，浮动之后，已经不区分行内、块级了。

- **标准流中的文字不会被浮动的盒子遮挡住**。（文字就像水一样）

- 关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：**永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。**

- 一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。

  <img src="https://gitee.com/leoschopen/picture/raw/master/null/20170801_1720.png" style="zoom:67%;" />

# day05

## 使用virtualenv创建虚拟环境时指定python版本

```
virtualenv -p F:\python3.6\python.exe task_pricing
```

## 请求转发

流程：

1. 输入地址
2. django获取地址
3. 和url,py进行匹配，记录下方法
4. 调用相应的方法名称，接收reqest的的请求，处理并返回response

- 正因为有了ROOT_URLCONF = 'bug_manage.urls'（setting.py文件中）才会去匹配url.py
- 从url中获取一个值（使用get，post方法，后面会接触）

## 新建应用

```
python manage.py startapp test_views
并在setting中的install app中添加    'app01',
```

# day06

## 项目结构

```
mysite/
    manage.py命令管理
    db.sqlite3 没啥用
    mysite/ 项目同名目录
        __init__.py//包初始化
        settings.py 项目启动配置文件 很多功能需要写配置来使用
        urls.py http请求进入django时优先调用
        asgi.py 
        wsgi.py web服务配置，正式启动需要用到
```

## url统一资源定位符

protocol://hostname:port/path/\[?query][#fragemrnt]

http://leoschopen.club/index.jsp port一般默认80



## 路由配置

- 地址请求到django后找setting里面的rootconfig，找到urlpattern

- path指定路由和具体地视图处理
- 从上到下依次匹配

```
path('admin/', admin.site.urls),
匹配到路由后显示后面的视图
path语法
path(路由（匹配的路径，视图处理函数（不加括号不是获取返回值），别名（反向解析的使用）)
```

### 视图函数

接收浏览器请求（HttpRequest对象）通过httrspon对象返回，视图函数接收请求根据逻辑返回相应的内容给browser

```
def mmm_view(request[,,,]):第一个参数一定是request

	return HttpResponse
```

### 路由配置，多个路由使用path转换器

```
path('page/<int:page>',views.xxx),
         <转换器类型：自定义名>按照关键字传参传给视图函数
         str leo 除掉斜杠
         int 100
         slug this-is-django 任意字母数字
         path 包含斜杠
```

#### 编写视图函数的时候，传参和使用占位符

```
def pagen_view(request,pg):
    html="<h1>page%s！</h1>"%(pg)
    return HttpResponse(html)
```



## 请求和响应

- ### request：浏览器通过protocol发送给服务端的数据

  - get请求页面返回实体

  - head类似get返回没有具体内容，获取报头

  - post提交数据，数据包在请求体中，（尤其是隐私信息）

  - put更新数据

  - delete删除页面

  - connect翻墙

  - option查看服务端的性能

  - trace用于测试，回显服务器收到的请求

    1. 请求在django实际是视图函数的参数，request对象自动生成

    2. ```
       request里面的参数：path_info url
       				method 方法get等
       				get：querydict查询字典的对象，包含get请求的所有数据
       				post：同上
       				files：包含所有上传文件的信息
       				cookies
       				session
       				body 请求体的内容，post或者put
       				scheme请求协议http等
       				request.getfullpath完整路径
       				。META元数据（消息头）
       				META['REMOTE_ADDR']和客户端的ip
       				
       def test_view(request):
           print('path info:',request.path_info)
           print('method:',request.method)
           print('querystring:',request.GET)
           print('client ip',request.META['REMOTE_ADDR'])
           print('FULL ADDR:',request.get_full_path)
           return HttpResponse("test ok")
           
           结果：
           访问：http://127.0.0.1:8000/test_request/?a=1&b=1
           path info: /test_request/
           method: GET
           querystring: <QueryDict: {'a': ['1'], 'b': ['1']}>
           client ip 127.0.0.1
           FULL ADDR: <bound method HttpRequest.get_full_path of <WSGIRequest: GET '/test_request/?a=1&b=1'>>
       ```

       

- ### response：接收并处理再返回给浏览器

请求状态码：

<img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1059.jpeg" alt="IMG_1059" style="zoom: 25%;" />

301 www.360buy -》www.jd

1. 响应对象（content=响应体，content_type=数据类型 status=状态码）
2. content_type
   - text/html
   - text/css ......
3. <img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1060.jpeg" alt="IMG_1060" style="zoom:25%;" />

## get请求和post请求

### get请求

1. 都是由视图函数接收请求，通过判断request.method来区分，查询数据，少量的数据

2. get请求给服务器传递数据，使用查询字符串：http://127.0.0.1:8000/test_request/?a=1&b=1

3. request.GET['a']   

   request.GET.get('c','default')查询不到则使用默认值

4. ```
   def test_get_post(request):
       if request.method=='GET':
           print(request.GET)
           print(request.GET['a'])
           print(request.GET.getlist('a'))
           print(request.GET.get('c','no c'))
       else:
           pass
       return HttpResponse('TEST POST OK')
       
       <QueryDict: {'a': ['100', '300']}>
       300
       ['100', '300']
       no c
   ```

### post请求

1. 提交大量，隐私数据

   ```
   <form method='post' action='/login'>
   ```

post不按规则走会被django的安全措施阻挡，有csrf验证，报403错误，拒绝客户端的POST

先暂时关闭

```
   # 'django.middleware.csrf.CsrfViewMiddleware',
```

# day07

## 传统MVC

- M模型，数据库封装
- V视图，展示
- C控制，处理请求返回结果

## MTV模式

- M模型，数据库交互
- T模板，呈现内容到浏览器（html）专门如何显示数据
  - 模板根据字典的动态变化生成页面

- V视图，负责接收请求，获取数据，返回结果

mvc的c层在这里其实是主路由



### 模板配置

templates文件夹

setting文件

```
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')]
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

### 模板加载

```
def test_html(request):
    # 早期方案，引入模板
    # from django.template import loader
    # t = loader.get_template('test_html.html')
    # html = t.render()
    # return HttpResponse(html)

    # 方法2
    from django.shortcuts import render
    return render(request,'test_html.html')
```

### 视图模板的交互

使用render的第三个参数（字典类型）

```
    return render(request,'test_html.html',dic)
   使用： {{变量名}}即字典的name
```

### 模板的变量和标签

<img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1061.jpeg" alt="IMG_1061" style="zoom:33%;" />

```c
标签
{% if %}
{% elif %}
{% else %}
{% endif %}

```

### 模板层的过滤器和继承

在变量输出时的变量的值进行处理，通过过滤器改变变量的输出显示

- lower

- upper

- safe不对字符串进行html转义

  ```python
  dic['script']=<script>alert(111)</script>
  
  html页面：{{script}}//进行转义了&lt；。。。&gt；
  {{script|safe}}
  ```

- add：“n”加n

  ```
  {{ age|add:"10"}}
  ```

### 模板继承

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220111215133984.png" alt="image-20220111215133984" style="zoom:25%;" />

导航栏每个页面都一样

模板继承可以使父模板的内容重用,子模板直接继承父模板的全部内容并可以覆盖父模板中相应的块语法–

父模板中:

- 定义父模板中的块 block标签
- 标识出哪些在子模块中是允许被修改的
- block标签:在父模板中定义，可以在子模板中覆盖

子模板

- 继承{%extends ‘father.html’%}

- 重写内容块

  {% block name%}

  {% endblock name%}

## url的反向解析

使用path定义的名称来动态查找或计算出相应的路由

<h4>只需要在路由中配置，其他页面自动变化</h4>

模板中：

{% url 'leo' age='18'%}

第二个参数是path里面的别名

### 反向解析的出现位置

- \<a href>
- \<form action>

- HttpResponseRedirect('')



![IMG_1063](https://gitee.com/leoschopen/picture/raw/master/null/IMG_1063.jpeg)

访问localhost:8000/test/url 三种链接的点击结果

绝对相对一样直接跳转，而不带/的结果为lh/test/test_url_result

### 302重定向

靠响应头里面的location

```python
def test_url_result(request,age):
    #302重定位跳转
    from django.urls import reverse
    url = reverse('base_index')
    return HttpResponseRedirect(url)
```

# day08

第三方服务

- API url
- SDK 模块，导入使用

使用redis

1. redis客户端

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220112192547678.png" alt="image-20220112192547678" style="zoom:67%;" />

2.利用安装模块

```
pip install redis
```

redis操作

```
启动
redis-cli
auth foobared
...

config set requirepass 123 //更改密码
```

### redis报redis.exceptions.AuthenticationError: Authentication required.

不知道这个和笔记本连wifi配的ip有无关系，最后改为localhost解决
