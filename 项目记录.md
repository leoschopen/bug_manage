# sass平台

SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统

# 知识点concerning

- 虚拟环境，多个python环境

  ```
  py3：
  	django 1.11 ->crm系统
  	django 2.0 ->路飞
  需要虚拟环境
  django/pymysql/sms(短信)/redis/celery
  虚拟1，虚拟2
  ```

  ```
  //local_setting.py本地配置
  开发和测试需要变换ip等对数据库配置等需要变动，要在localsetting本地配置中修改省事，统一配置而非每个文件中写
  try：
  except：
  databases：
  /除了localsetting以外的给测试
  ```

- 腾讯云平台

  - sms短信

  - cos对象存储，腾讯给云硬盘，项目中上传文件、查看文件、下载文件

    >使用自己的电脑速度慢，通过对象存储将压力交给腾讯云对象存储

- redis

  ```
  mysql
   自己                  另外的电脑
   pymysql          -》mysql软件-》行为（硬盘文件操作crud）
   
   mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。
  redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。
   本质区别是mysql是对硬盘文件操作，redis是对内存的操作，redis速度更快
   
   redis
   自己                  另外
   pymysql         -》   redis软件-》（
                                     set name = “s”在内存中创造
                                     get name 在内存中获取
                                     可以对数据进行超时时间进行过期处理
  ```

  # 开发安排

  - 一期：用户认证（短信，验证码，django modelform）
  - 二期：wiki，文件，问题
  - 三期：支付，部署，linux

# day01

1.虚拟环境

- 使用virtualenv

  ```
  pip3 install virtualenv
  
  创建：virtualenv name （--python=python3.7.8//需要配置环境变量）
  会创建一个文件夹包含此环境
  
  激活：scripts目录
  activate.exe
  ```

2，配置local_settings

## git

```
Microsoft Windows [版本 10.0.18363.1556]
(c) 2019 Microsoft Corporation。保留所有权利。
//本地初始化
(bug_manage) D:\PyProject\bug_manage>git init
Initialized empty Git repository in D:/PyProject/bug_manage/.git/
//选中所有
(bug_manage) D:\PyProject\bug_manage>git add .
//命名
(bug_manage) D:\PyProject\bug_manage>git commit -m '第一次提交'

//起别名
(bug_manage) D:\PyProject\bug_manage>git remote add origin https://github.com/leoschopen/bug_manage.git
//push
(bug_manage) D:\PyProject\bug_manage>git push origin master


```

# day02

## abstract

- 腾讯sms
- django的ModelForm组件
- redis
- 注册逻辑设计

## 虚拟环境搭配模块版本描述

需求版本生成文件

pip freeze > requirements.txt

pip install -r requirements.txt

## git的一个错误

```
To https://github.com/leoschopen/bug_manage.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'https://github.com/leoschopen/bug_manage.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
分析：
可能是手动在github创建了readme，我们在关联本地与远程时，两端都是有内容的，但是这两份内容并没有联系，当我们推送到远程或者从远程拉取内容时，都会有没有被跟踪的内容，于是你看git报的详细错误中总是会让你先拉取再推送，但是拉取总是失败。
解决：对于error: failed to push some refs to‘远程仓库地址’
1 使用如下命令
git pull --rebase origin master

2 然后再进行上传:

git push -u origin master
```

## doubts

- httpresponse的原理
- django的有关传输和操作不熟悉。感觉和servlet有点像，但是servlet也忘记完了
- ajax的过程

## ModelForm

- 使用modelform生成页面上的一些基本字段

- 自动生成标签

```python
#models.py
from django.db import models

# Create your models here.
class UserInfo(models.Model):
    username= models.CharField(verbose_name='用户名',max_length=32)
    email = models.EmailField(verbose_name='邮箱',max_length=32)
    mobile_phone = models.CharField(verbose_name='手机号',max_length=32)
    password = models.CharField(verbose_name='密码',max_length=32)
   
#views.py
from django import forms
from app01 import models
from django.core.validators import RegexValidator

class RegisterModelForm(forms.ModelForm):
    """如果原来的modelform原来定义得有，重复则重写，否则添加"""
    #手机号验证
    mobile_phone = forms.CharField(
        label='手机号',
        validators=[RegexValidator(r'^(1[3|4|5|6|7|8|9])\d{9}$','手机号格式错误'),])#正则表达式
    #密码密文展示,并确定标签的属性
    password = forms.CharField(
        label='密码',
        widget=forms.PasswordInput())
    #重复输入密码
    confirm_password = forms.CharField(
        label='重复密码',
        widget=forms.PasswordInput())
    #验证码
    code = forms.CharField(
        label='验证码',
        widget=forms.TextInput())
    class Meta:
        model = models.UserInfo
        fields = "__all__"
    #重写init函数每个标签的class都设置为form—control
    def __init__(self,*args,**kwargs):
        super().__init__(*args,**kwargs)
        for name,field in self.fields.items():
            field.widget.attrs['class'] = 'form-control'
            field.widget.attrs['placeholder'] = '请输入%s' % field.label

def register(request):
    form = RegisterModelForm()
    return render(request,'register.html',{'form':form})
    
```

## 使用bootstrap写前端的页面

```
 #循环生成
 {% for field in form %}
      <div class="form-group">
            <label for="{{ field.id_for_label }}">{{ field.label }}</label>
              {% comment %}<input type="email" class="form-control" id="exampleInputEmail"     placeholder="Email">{% endcomment %}
               {{ field }}
              </div>
                {% endfor %}
                
#重写init函数为组件添加默认class和有关属性
```

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220107233215300.png" alt="image-20220107233215300" style="zoom:33%;" />

- 形状不对齐

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220107234614031.png" alt="image-20220107234614031" style="zoom:50%;" />

解决方法padding-left

```html
<div class="col-md-6" style="padding-left: 0;">{{ field }}</div> 
```

- 将页面注册字段的顺序进行调整

  > 默认是根据modelform的顺序加上后续添加的顺序

  解决方法：

  ```
     class Meta:
          model = models.UserInfo
          fields = "__all__"   
     class Meta:
          model = models.UserInfo
          fields = ['username','email','password','confirm_password','mobile_phone','code']
  ```

  

## 验证码实现

- 获取手机号

- 后台发ajax

  - 参数：号码，tpl=register

- 向手机发短信

  - 验证码的时效的处理60s

  - 书局存储在redis上

    ![image-20220108000730304](https://gitee.com/leoschopen/picture/raw/master/null/image-20220108000730304.png)

1. 我调api发给腾讯（申请验证码过程）
2. 腾讯发给用户
3. 同时我把验证码放在redis中，设置失效时间并验证（注册按钮）

# day03

- 任务
  - modelform页面
  - ajax请求，向后台传手机号和tql
  - sms+redis
  - 字段校验，验证码校验
  - 倒计时效果

## pip安装第三方库 Non-zero exit code(2)报错

解决方法：

- pip install --upgrade pip升级pip（失效）
- pip install redis -i https://pypi.tuna.tsinghua.edu.cn/simple（使用第三方库）（成功）
-   阿里云 http://mirrors.aliyun.com/pypi/simple
      中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple
      豆瓣(douban) http://pypi.douban.com/simple
      清华大学 https://pypi.tuna.tsinghua.edu.cn/simple
      中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple
- <img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220108105745499.png" alt="image-20220108105745499" style="zoom:50%;" />

发现添加数据源之后已然不能再仓库中搜索下载，还是使用命令吧

使用国内镜像又报错

Cannot determine archive format of C:\Users\ZYZYLE~1\AppData\Local\Temp\pip-req-build-62t0iy4y

```
pip install -i http://pypi.douban.com/simple/ --trusted-host=pypi.douban.com/simple django-ckeditor
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host=pypi.tuna.tsinghua.edu.cn/simple django-ckeditor
pip install -i http://mirrors.aliyun.com/pypi/simple --trusted-host=mirrors.aliyun.com/pypi/simple django-ckeditor
```

[替换镜像源方法](https://cloud.tencent.com/developer/article/1520882)

# day04

- 补坑

## css补充

- ### 样式的优先级：标签高于头部高于文件

- ### 选择器：

  ```
  标签选择
  span {
         color: red;
  }
  
  
  ### ID 选择器：规定用`#`来定义
  针对某一个特定的标签来使用，只能使用一次。css 中的 ID 选择器以”#”来定义。
  #mytitle{ border:3px dashed green; }
     
     
  ### 类选择器：规定用圆点`.`来定义针对**你想要的所有**标签使用。优点：灵活。
  css 中用`.`来表示类。举例如下：
  .one{ width:800px; }
  
  
  后代选择器
   div div p {
                  color: red;
  }
   <div class="div3">
        <div class="div4">
              <p>我是什么颜色？</p>
        </div>
  </div>
  
  
  
  交集选择器
  h3.special {
      color: red;
  }
          <h3 class="special zhongyao">标题1</h3>
          <h3 class="special">我也是标题</h3>
          
         
  并集选择器 ：定义的时候用逗号隔开 
  p,
  h1,
  #mytitle,
  .one {
      color: red;
  }
  
  子代选择器
  div > p {
      color: red;
  }
  <div>
      <p>我是div的儿子</p>
  </div>
  
  序选择器
      ul li:first-child {
          color: red;
      }
      <ul>
      <li class="first">项目</li>
      <li>项目</li>
      <li>项目</li>
      
      
  下一个兄弟选择器 `+`表示选择下一个兄弟   
  选择的是 h3 元素后面紧挨着的第一个兄弟。    
  
  ```

  <img src="https://gitee.com/leoschopen/picture/raw/master/null/20170711_1950.png" style="zoom:67%;" />

### 行级元素与块级元素

行内元素：

- 与其他行内元素并排；
- 不能设置宽、高。默认的宽度，就是文字的宽度。

块级元素：

- 霸占一行，不能与其他任何元素并列；
- 能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。

<img src="https://gitee.com/leoschopen/picture/raw/master/null/20170729_1532_2.png" style="zoom:67%;" />

<img src="https://gitee.com/leoschopen/picture/raw/master/null/20170729_1545.png" style="zoom:67%;" />

### 行内元素和块级元素的相互转换

#### 块级元素可以转换为行内元素：

一旦，给一个块级元素（比如div）设置：

```
display: inline;
```

那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说：

- 此时这个div不能设置宽度、高度；
- 此时这个div可以和别人并排了。

<img src="https://gitee.com/leoschopen/picture/raw/master/null/20170729_1629.png" style="zoom:67%;" />

#### 行内元素转换为块级元素：

同样的道理，一旦给一个行内元素（比如span）设置：

```
display: block;
```

那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说：

- 此时这个span能够设置宽度、高度
- 此时这个span必须霸占一行了，别人无法和他并排
- 如果不设置宽度，将撑满父亲

举例如下：

![](https://gitee.com/leoschopen/picture/raw/master/null/20170729_1638.png)

标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：移民！**脱离标准流**！


css中一共有三种手段，使一个元素脱离标准文档流：

- （1）浮动
- （2）绝对定位
- （3）固定定位

- 所有标签，浮动之后，已经不区分行内、块级了。

- **标准流中的文字不会被浮动的盒子遮挡住**。（文字就像水一样）

- 关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：**永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。**

- 一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。

  <img src="https://gitee.com/leoschopen/picture/raw/master/null/20170801_1720.png" style="zoom:67%;" />

# day05

## 使用virtualenv创建虚拟环境时指定python版本

```
virtualenv -p F:\python3.6\python.exe task_pricing
```

## 请求转发

流程：

1. 输入地址
2. django获取地址
3. 和url,py进行匹配，记录下方法
4. 调用相应的方法名称，接收reqest的的请求，处理并返回response

- 正因为有了ROOT_URLCONF = 'bug_manage.urls'（setting.py文件中）才会去匹配url.py
- 从url中获取一个值（使用get，post方法，后面会接触）

## 新建应用

```
python manage.py startapp test_views
并在setting中的install app中添加    'app01',
```

# day06

## 项目结构

```
mysite/
    manage.py命令管理
    db.sqlite3 没啥用
    mysite/ 项目同名目录
        __init__.py//包初始化
        settings.py 项目启动配置文件 很多功能需要写配置来使用
        urls.py http请求进入django时优先调用
        asgi.py 
        wsgi.py web服务配置，正式启动需要用到
```

## url统一资源定位符

protocol://hostname:port/path/\[?query][#fragemrnt]

http://leoschopen.club/index.jsp port一般默认80



## 路由配置

- 地址请求到django后找setting里面的rootconfig，找到urlpattern

- path指定路由和具体地视图处理
- 从上到下依次匹配

```
path('admin/', admin.site.urls),
匹配到路由后显示后面的视图
path语法
path(路由（匹配的路径，视图处理函数（不加括号不是获取返回值），别名（反向解析的使用）)
```

### 视图函数

接收浏览器请求（HttpRequest对象）通过httrspon对象返回，视图函数接收请求根据逻辑返回相应的内容给browser

```
def mmm_view(request[,,,]):第一个参数一定是request

	return HttpResponse
```

### 路由配置，多个路由使用path转换器

```
path('page/<int:page>',views.xxx),
         <转换器类型：自定义名>按照关键字传参传给视图函数
         str leo 除掉斜杠
         int 100
         slug this-is-django 任意字母数字
         path 包含斜杠
```

#### 编写视图函数的时候，传参和使用占位符

```
def pagen_view(request,pg):
    html="<h1>page%s！</h1>"%(pg)
    return HttpResponse(html)
```



## 请求和响应

- ### request：浏览器通过protocol发送给服务端的数据

  - get请求页面返回实体

  - head类似get返回没有具体内容，获取报头

  - post提交数据，数据包在请求体中，（尤其是隐私信息）

  - put更新数据

  - delete删除页面

  - connect翻墙

  - option查看服务端的性能

  - trace用于测试，回显服务器收到的请求

    1. 请求在django实际是视图函数的参数，request对象自动生成

    2. ```
       request里面的参数：path_info url
       				method 方法get等
       				get：querydict查询字典的对象，包含get请求的所有数据
       				post：同上
       				files：包含所有上传文件的信息
       				cookies
       				session
       				body 请求体的内容，post或者put
       				scheme请求协议http等
       				request.getfullpath完整路径
       				。META元数据（消息头）
       				META['REMOTE_ADDR']和客户端的ip
       				
       def test_view(request):
           print('path info:',request.path_info)
           print('method:',request.method)
           print('querystring:',request.GET)
           print('client ip',request.META['REMOTE_ADDR'])
           print('FULL ADDR:',request.get_full_path)
           return HttpResponse("test ok")
           
           结果：
           访问：http://127.0.0.1:8000/test_request/?a=1&b=1
           path info: /test_request/
           method: GET
           querystring: <QueryDict: {'a': ['1'], 'b': ['1']}>
           client ip 127.0.0.1
           FULL ADDR: <bound method HttpRequest.get_full_path of <WSGIRequest: GET '/test_request/?a=1&b=1'>>
       ```

       

- ### response：接收并处理再返回给浏览器

请求状态码：

<img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1059.jpeg" alt="IMG_1059" style="zoom: 25%;" />

301 www.360buy -》www.jd

1. 响应对象（content=响应体，content_type=数据类型 status=状态码）
2. content_type
   - text/html
   - text/css ......
3. <img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1060.jpeg" alt="IMG_1060" style="zoom:25%;" />

## get请求和post请求

### get请求

1. 都是由视图函数接收请求，通过判断request.method来区分，查询数据，少量的数据

2. get请求给服务器传递数据，使用查询字符串：http://127.0.0.1:8000/test_request/?a=1&b=1

3. request.GET['a']   

   request.GET.get('c','default')查询不到则使用默认值

4. ```
   def test_get_post(request):
       if request.method=='GET':
           print(request.GET)
           print(request.GET['a'])
           print(request.GET.getlist('a'))
           print(request.GET.get('c','no c'))
       else:
           pass
       return HttpResponse('TEST POST OK')
       
       <QueryDict: {'a': ['100', '300']}>
       300
       ['100', '300']
       no c
   ```

### post请求

1. 提交大量，隐私数据

   ```
   <form method='post' action='/login'>
   ```

post不按规则走会被django的安全措施阻挡，有csrf验证，报403错误，拒绝客户端的POST

先暂时关闭

```
   # 'django.middleware.csrf.CsrfViewMiddleware',
```

# day07

## 传统MVC

- M模型，数据库封装
- V视图，展示
- C控制，处理请求返回结果

## MTV模式

- M模型，数据库交互
- T模板，呈现内容到浏览器（html）专门如何显示数据
  - 模板根据字典的动态变化生成页面

- V视图，负责接收请求，获取数据，返回结果

mvc的c层在这里其实是主路由



### 模板配置

templates文件夹

setting文件

```
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')]
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

### 模板加载

```
def test_html(request):
    # 早期方案，引入模板
    # from django.template import loader
    # t = loader.get_template('test_html.html')
    # html = t.render()
    # return HttpResponse(html)

    # 方法2
    from django.shortcuts import render
    return render(request,'test_html.html')
```

### 视图模板的交互

使用render的第三个参数（字典类型）

```
    return render(request,'test_html.html',dic)
   使用： {{变量名}}即字典的name
```

### 模板的变量和标签

<img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1061.jpeg" alt="IMG_1061" style="zoom:33%;" />

```c
标签
{% if %}
{% elif %}
{% else %}
{% endif %}

```

### 模板层的过滤器和继承

在变量输出时的变量的值进行处理，通过过滤器改变变量的输出显示

- lower

- upper

- safe不对字符串进行html转义

  ```python
  dic['script']=<script>alert(111)</script>
  
  html页面：{{script}}//进行转义了&lt；。。。&gt；
  {{script|safe}}
  ```

- add：“n”加n

  ```
  {{ age|add:"10"}}
  ```

### 模板继承

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220111215133984.png" alt="image-20220111215133984" style="zoom:25%;" />

导航栏每个页面都一样

模板继承可以使父模板的内容重用,子模板直接继承父模板的全部内容并可以覆盖父模板中相应的块语法–

父模板中:

- 定义父模板中的块 block标签
- 标识出哪些在子模块中是允许被修改的
- block标签:在父模板中定义，可以在子模板中覆盖

子模板

- 继承{%extends ‘father.html’%}

- 重写内容块

  {% block name%}

  {% endblock name%}

## url的反向解析

使用path定义的名称来动态查找或计算出相应的路由

<h4>只需要在路由中配置，其他页面自动变化</h4>

模板中：

{% url 'leo' age='18'%}

第二个参数是path里面的别名

### 反向解析的出现位置

- \<a href>
- \<form action>

- HttpResponseRedirect('')



![IMG_1063](https://gitee.com/leoschopen/picture/raw/master/null/IMG_1063.jpeg)

访问localhost:8000/test/url 三种链接的点击结果

绝对相对一样直接跳转，而不带/的结果为lh/test/test_url_result

### 302重定向

靠响应头里面的location

```python
def test_url_result(request,age):
    #302重定位跳转
    from django.urls import reverse
    url = reverse('base_index')
    return HttpResponseRedirect(url)
```

# day08

第三方服务

- API url
- SDK 模块，导入使用

使用redis

1. redis客户端
2. 

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220112192547678.png" alt="image-20220112192547678" style="zoom:67%;" />

2.利用安装模块

```
pip install redis
```

redis操作

```
启动
redis-cli
auth foobared
...

config set requirepass 123 //更改密码
```

### redis报redis.exceptions.AuthenticationError: Authentication required.

不知道这个和笔记本连wifi配的ip有无关系，最后改为localhost解决

### python控制台输出乱码b'\xe6\xad\xa6\xe6\xb2\x9b\xe9\xbd\x90'

使用print(value.decode())

# day09

任务：实现注册

## ajax

1. ajax的type属性选择post还是get，前者用于上传更新，或者大量的数据，后者用于获取数据



- 创建app

- 创建模板

  - 模板的顺序是根据setting里面的installapp顺序去每个app里面查找，

  - 则需要在templates默认创建一个同名文件夹，引入的时候加上

  - ```py
    def register(request):
        return render(request, 'web/register.html')
    ```


# day10

## 1.modelform的功能：

一个是展示页面，一个是对页面的请求进行校验，对哪个字段进行校验就设置谁的钩子函数（clean_xxx)

在本项目中是提交之前对数据进行校验

```python
获取数据
    def clean_username(self):
        username = self.cleaned_data['username']
注意获取cleanddata的时候是有顺序的，还未校验的数据在该列表中时不存在的
fields = ['username', 'email', 'password', 'confirm_password', 'mobile_phone', 'code']
在校验password的时候，后面三个是不存在的

获取存在的状态：
exists = models.UserInfo.objects.filter(username=username).exists()


数据写入数据库中：
form.save()
相当于是做了：
data=form.cleaned_data
data.pop('code')
instance=models.UserInfo.objects.create(**data)


//数据加密
def md5(string):
    """ MD5加密 """
    hash_object = hashlib.md5(settings.SECRET_KEY.encode('utf-8'))#加盐
    hash_object.update(string.encode('utf-8'))
    return hash_object.hexdigest()
```

为models的字段创建db_index，orm检索会更快

```
username= models.CharField(verbose_name='用户名',max_length=32,db_index=True)
```



## 1.1migration&migrate

在你改动了 model.py的内容之后执行下面的命令：

```python
python manage.py makemigrations
```

相当于在该app下建立 migrations目录，并记录下你所有的关于modes.py的改动，比如0001_initial.py， 但是这个改动还没有作用到[数据库]文件

在 makemigrations之后执行命令：

```python
python manage.py migrate
```



## 1.2关于自带sqlite数据库不显示表内容的解决方法：

<img src="C:\Users\zyzylenovo\AppData\Roaming\Typora\typora-user-images\image-20220126113335285.png" alt="image-20220126113335285" style="zoom:50%;" />

[右侧栏的DataBase没有生成schemas和collations的解决方法](https://blog.csdn.net/weixin_39964660/article/details/110078230?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.pc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=4)



## 1.3关于钩子函数顺序验证带来的小bug

如果上面的没有验证通过，下面的无法拿到值,使用get方式拿

```python
def clean_confirm_password(self):
    pwd = self.cleaned_data.get('password')
```



## 2.短信登录

### 2.1新建的页面没有bootstrap样式

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220126122734447.png" alt="image-20220126122734447" style="zoom:67%;" />

重写其init方法为其加上bootstrap的对应class

```python
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for name, field in self.fields.items():
            field.widget.attrs['class'] = 'form-control'
            field.widget.attrs['placeholder'] = '请输入%s' % (field.label,)
```

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220126123108235.png" alt="image-20220126123108235" style="zoom:67%;" />

```python
为了减少代码量，单独设置一个bootstrap类
class RegisterModelForm(BootStrapForm,forms.ModelForm):

#!/usr/bin/env python
# -*- coding:utf-8 -*-

class BootStrapForm(object):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for name, field in self.fields.items():
            field.widget.attrs['class'] = 'form-control'
            field.widget.attrs['placeholder'] = '请输入%s' % (field.label,)

```

### 2.2用户登录时手机号要是存在才能登录，和注册的提示不同

```python
#检查数据库中是否已经有手机号（没注册过）
exists = models.UserInfo.objects.filter(mobile_phone=mobile_phone).exists()
if tpl == 'login':
    #登陆的时候要求的是手机号存在
    if not exists:
        raise ValidationError('手机号未注册')
else:
    # 校验数据库中是否已有手机号，注册要求不存在
    if exists:
        raise ValidationError('手机号已存在')
```

## 3.用户名&密码登录

### 3.1 python生成验证码

[验证码](https://www.cnblogs.com/wupeiqi/articles/5812291.html)

### 3.2 session和cookies

c端的字符串（seesionid）去session中找里面的特定区域，和里面的内容（sessiondata）进行匹配，看是否登陆过，django的session的过期时间默认为2周，可以在sqlite的数据库中查看

<img src="https://gitee.com/leoschopen/picture/raw/master/null/IMG_1116.jpeg" alt="IMG_1116" style="zoom: 33%;" />

![image-20220126210335252](https://gitee.com/leoschopen/picture/raw/master/null/image-20220126210335252.png)

![image-20220126210427655](https://gitee.com/leoschopen/picture/raw/master/null/image-20220126210427655.png)

也可以用redis只不过session可以生成id比较方便

### 3.3 验证码页面显示

```python
建立路由
url(r'^image/code/$',account.image_code, name='image_code'), # image

让图片的路径去请求相应的路由
<img src="{% url 'image_code' %}">
```

#### 验证码点击更新

```python
    <script>
    $(function(){
        $('#imageCode').click(function(){
            var oldSrc = $(this).attr('src');
            $(this).attr('src', oldSrc + "?");//给地址加上？就会重新发请求
        })
    })
    </script>
```

### 3.4 登录

用户名或者邮箱+密码登录的验证

```python
def login(request):
    """ 用户名和密码登录 """
    if request.method == 'GET':
        form = LoginForm(request)
        return render(request, 'login.html', {'form': form})
    form = LoginForm(request, data=request.POST)
    if form.is_valid():
        username = form.cleaned_data['username']
        password = form.cleaned_data['password']

        # user_object = models.UserInfo.objects.filter(username=username, password=password).first()
        #  (手机=username and pwd=pwd) or (邮箱=username and pwd=pwd)
        
        user_object = models.UserInfo.objects.filter(Q(email=username) | Q(mobile_phone=username)).filter(
            password=password).first()
        if user_object:
            # 登录成功为止1
            request.session['user_id'] = user_object.id
            request.session.set_expiry(60 * 60 * 24 * 14)
            return redirect('index')

        form.add_error('username', '用户名或密码错误')

    return render(request, 'login.html', {'form': form})
```

密码刷新不丢失render_value=True

```
password = forms.CharField(label="密码",widget=PasswordInput(render_value=True))
```



# day11

## 1.django离线运行

一般用于庞大数据的录入

```python
离线即非网站运行时即运行

脚本，一个或多个py文件
在某个py文件中对python的项目进行处理



from web import models
# 往数据库添加数据：链接数据库、操作、关闭链接
models.UserInfo.objects.create(username='陈硕', email='chengshuo@live.com', mobile_phone='13838383838', password='123123')
会报错


解决方法：
from web import models
import django
import os
import sys

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(base_dir)#将项目的路径加入到sys.path这样django启动之后就可以知道路径了
os.environ.setdefault('DJANGO_SETTINGS_MODULE',"bug_manage.settings")
django.setup()

# 往数据库添加数据：链接数据库、操作、关闭链接
models.UserInfo.objects.create(username='陈硕', email='chengshuo@live.com', mobile_phone='13838383838', password='123123')
```

## 2.价格策略

### 2.1用户充会员

| 分类                         | 标题     | 价格                       | 创建任务个数 | 每个项目参与人数 | 上传总空间 | 单个文件大小 | 创建时间 |
| :--------------------------- | -------- | -------------------------- | ------------ | ---------------- | ---------- | ------------ | -------- |
| 自定（收费版）               | VIP 199  | 自拟                       | 100          | 100              | 200M       | 50M          |          |
| 自定（收费版，上下多少浮动） | SVIP 299 | 自拟                       | 200          | 1000             | 1G         | 100M         |          |
| 平台推荐（免费版）           | 免费 0   | 根据经纬度、会员信誉等确定 | 3            | 2                | 20M        | 5M           |          |
|                              |          |                            |              |                  |            |              |          |

新用户注册有额度



### 交易记录

| ID   | 状态          | 用户 | 价格 | 实际支付 | 数量 | 订单号 | 开始 | 结束 |
| ---- | ------------- | ---- | ---- | -------- | ---- | ------ | ---- | ---- |
|      | 已支付/未支付 | 1    | 5    |          |      |        |      |      |

### 2.2 用户与任务价格之间的联系

用户和价格如何进行对应，关联

| 会员名 | 手机号 | 密码 |
| ------ | ------ | ---- |
|        |        |      |

### 2.3 创建存储

会员上传文件，依赖腾讯对象存储COS存储数据

### 2.4 任务表

| ID   | 项目名称 | 描述   | 佣金 | 星标 | 参与人数 | 创建者 | 已参与人数 |
| ---- | -------- | ------ | ---- | ---- | -------- | ------ | ---------- |
| 1    |          | 拿快递 | 50   | true | 5        | 3      | 1          |

### 2.5 任务领取者（会员）

| ID   | 任务 | 领取用户 | 星标 | 领取价格 | 任务完成状态 |      |      |      |
| ---- | ---- | -------- | ---- | -------- | ------------ | ---- | ---- | ---- |
|      |      |          |      |          |              |      |      |      |





## 3.任务

### 3.1创建表结构

遇到外键级联问题

### 3.2创建离线脚本创建价格策略

| 分类               | 标题   | 价格                       | 创建任务个数 | 每个项目参与人数 | 每个项目空间 | 单个文件大小 | 创建时间 |
| :----------------- | ------ | -------------------------- | ------------ | ---------------- | ------------ | ------------ | -------- |
| 平台推荐（免费版） | 免费 0 | 根据经纬度、会员信誉等确定 | 3            | 2                | 20M          | 5M           |          |

### 3.3用户注册

新建用户后，在用户表和免费版交易记录中添加记录

### 3.4新建任务+颜色选择

使用面向对象的方法跳过对color栏使用form-control的class

```python
1.部分样式应用
class BootStrapForm(object):

    bootstrap_class_exclude = []

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for name, field in self.fields.items():
            if name in self.bootstrap_class_exclude:
                continue
            field.widget.attrs['class'] = 'form-control'
            field.widget.attrs['placeholder'] = '请输入%s' % (field.label,)
            
            
#子类继承，实例化的时候会走init，self即ProjectModelForm即拿到这里的color            
class ProjectModelForm(BootStrapForm, forms.ModelForm):
    bootstrap_class_exclude = ['color']
    
    
    2.定制modelform
    
   在表单这里为选项加上属性，在前端页面写选择并应用样式 
     class Meta:
        model = models.Project
        fields = ['name', 'task_price','color', 'desc']
        #重写插件CharField变Textarea
        widgets = {
            'desc': forms.Textarea,
            'color': ColorRadioSelect(attrs={'class': 'color-radio'}),
        }
        
        class ColorRadioSelect(RadioSelect):
    template_name = 'widgets/color-radio/radio.html'
    option_template_name = 'widgets/color-radio/radio_option.html'
        
        
        
     
        .color-radio label {
            margin-left: 0;
            padding-left: 0;
        }

        .color-radio input[type="radio"] {
            display: none;
        }

        .color-radio input[type="radio"] + .cycle {
            display: inline-block;
            height: 25px;
            width: 25px;
            border-radius: 50%;
            border: 2px solid #dddddd;
        }

        .color-radio input[type="radio"]:checked + .cycle {
            border: 2px solid black;
        }
```



### 3.5展示任务

- 星标
- 我创建
- 我参与

从数据库中获取：（都分为已经星标和未星标）

1. 我创建
2. 我参与

```
  flex布局，    
      .panel-body {
            padding: 0;
            display: flex;    flex布局
            flex-direction: row;	行排列
            justify-content: left;	水平方式放左边
            align-items: flex-start;	上下对齐方式从左上角开始
            flex-wrap: wrap;	如果数据堆得多了自动换行
        }
```



### 3.6星标项目（一点就去到那一栏）

```
def project_star(request, project_type, project_id):
    """ 星标项目 """
    if project_type == 'my':
        models.Project.objects.filter(id=project_id, creator=request.tracer.user).update(star=True)
        return redirect('project_list')

    if project_type == 'join':
        models.ProjectUser.objects.filter(project_id=project_id, user=request.tracer.user).update(star=True)
        return redirect('project_list')

    return HttpResponse('请求错误')
    
    
在project_list中进行数据库查询并使用form进行展示
```



### 3.7项目切换+菜单

1. 数据库获取

2. 点击菜单栏项目，循环显示

   采用inclusion_tag 

   ```
   {% all_project_list  request %}
   
   在templatetags中创建
   ```

   

### 3.8wiki管理

### 3.9更换django，redis

发现有一些报错，以为是版本不正确的原因，遂降低版本，最后报错，一个是seesionStore的错误另一个是base64的解码错误，最后清理cookies解决，最后发现报错依然存在。啊这。。。



```
django.template.exceptions.TemplateSyntaxError: 'all_project_list' received too many positional arguments

{% all_project_list request %}


解决：焊管，定义的函数需要参数，在定义的时候就没有把参数写进去
```

# day12

## 1 项目管理

### 1.1中间件

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220203105638435.png" alt="image-20220203105638435" style="zoom:50%;" />

```python
url(r'^manage/(?P<project_id>\d+)/', include([


    def process_view(self, request, view, args, kwargs):

        # 判断URL是否是以manage开头，如果是则判断项目ID是否是我创建 or 参与
        if not request.path_info.startswith('/manage/'):
            return

        project_id = kwargs.get('project_id')
        # 是否是我创建的
        project_object = models.Project.objects.filter(creator=request.tracer.user, id=project_id).first()
        if project_object:
            # 是我创建的项目的话，我就让他通过
            request.tracer.project = project_object
            return

        # 是否是我参与的项目
        project_user_object = models.ProjectUser.objects.filter(user=request.tracer.user, project_id=project_id).first()
        if project_user_object:
            # 是我参与的项目
            request.tracer.project = project_user_object.project
            return

        return redirect('project_list')
    
    
    实现是我的项目页面则有菜单栏显示，非我创建的项目则会跳转到原页面

```

### 1.2设置点击选中样式

```python
def manage_menu_list(request):
    data_list = [
        {'title': '概览', 'url': reverse("dashboard", kwargs={'project_id': request.tracer.project.id})},
        {'title': '问题', 'url': reverse("issues", kwargs={'project_id': request.tracer.project.id})},
        {'title': '统计', 'url': reverse("statistics", kwargs={'project_id': request.tracer.project.id})},
        {'title': 'wiki', 'url': reverse("wiki", kwargs={'project_id': request.tracer.project.id})},
        {'title': '文件', 'url': reverse("file", kwargs={'project_id': request.tracer.project.id})},
        {'title': '配置', 'url': reverse("setting", kwargs={'project_id': request.tracer.project.id})},
    ]

    for item in data_list:
        # 当前用户访问的URL：request.path_info:  /manage/4/issues/xxx/add/
        if request.path_info.startswith(item['url']):
            item['class'] = 'active'

    return {'data_list': data_list}
```



# day13

## 1.文件操作

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220203113146835.png" alt="image-20220203113146835" style="zoom:67%;" />

浏览器去cos上传前，要先去django验证获取凭证，根据获得的token去cos里上传，页面展示数据库存的的文件名，而下载从cos下载

## 2.点击生成模态对话框

```html
<div>
	<a class="btn btn-success btn-xs" data-toggle="modal" data-target="#addModal" data-whatever="新建文件夹">
    	<i class="fa fa-plus-circle" aria-hidden="true"></i> 新建文件夹
    </a>
</div>
                
                
                
                
<script>
        var FOLDER_URL = "{% url 'file' project_id=request.tracer.project.id %}";
        var FILE_DELETE_URL = "{% url 'file_delete' project_id=request.tracer.project.id %}";

        $(function () {
            initAddModal();
            bindModelSubmit();
            bindDeleteSubmit();
        });

        function bindDeleteSubmit() {
            $('#btnDelete').click(function () {
                // 获取要删除那行ID
                $.ajax({
                    url: FILE_DELETE_URL,
                    type: "GET",
                    data: {fid: $(this).attr('fid')},
                    success: function (res) {
                        if(res.status){
                            location.href = location.href;
                        }
                    }
                })
            })
        }

        function initAddModal() {
            $('#addModal').on('show.bs.modal', function (event) {
                var button = $(event.relatedTarget); // Button that triggered the modal
                var recipient = button.data('whatever'); // Extract info from data-* attributes
                var name = button.data('name'); // Extract info from data-* attributes
                var fid = button.data('fid'); // Extract info from data-* attributes
                var modal = $(this);
                modal.find('.modal-title').text(recipient);

                if (fid) {
                    // 编辑
                    modal.find('#id_name').val(name);
                    modal.find('#fid').val(fid);
                } else {
                    // 新建
                    modal.find('.error-msg').empty();
                    $('#form')[0].reset();
                }
            });

            $('#alertModal').on('show.bs.modal', function (event) {
                var button = $(event.relatedTarget); // Button that triggered the modal
                var fid = button.data('fid'); // Extract info from data-* attributes
                $('#btnDelete').attr('fid', fid);

            })
        }

        function bindModelSubmit() {
            $('#btnFormSubmit').click(function () {
                $.ajax({
                    url: location.href,
                    type: "POST",
                    data: $("#form").serialize(),
                    dataType: "JSON",
                    success: function (res) {
                        if (res.status) {
                            location.href = location.href;
                        } else {
                            $.each(res.error, function (key, value) {
                                $("#id_" + key).next().text(value[0]);
                            })
                        }
                    }
                })
            })
        }
</script>
```



## 数据库设计



| ID   | 任务ID | 文件名、文件夹名 | 类型 | 大小 | 父目录 | key  |
| ---- | ------ | ---------------- | ---- | ---- | ------ | ---- |
|      |        |                  |      |      |        |      |



## 3.删除对话框

```
// 获取要删除那行ID
//点击删除的时候获取这一行的id，绑定到删除确定按钮上fib的属性
```

## 4，腾讯云存储

[python sdk](https://cloud.tencent.com/document/product/436/12269)

创建项目时创建桶

文件操作：

- 目录切换
- 删除文件夹
- js上传cos
- 删除文件，级联删除数据库与cos
- 上传的进度条
- 下载文件

浏览器将文件传给cos，再把文件名传给django存在db中





# day14

## url传参&不传参

```
url(r'^index/$',home.index,name='index'),
```

```python
#/file/?folder_id=50
def file(request.project_id):
	folder_id = request.GET.get(folder_)
```

## 临时秘钥上传文件

用户请求django，获得临时凭证，带着这个凭证去上传

此外创建桶的时候有要求存储桶名称（BucketName）：由用户手动输入的一串字符，命名规范如下：

- 仅支持小写英文字母和数字，即[a-z，0-9]、中划线“-”及其组合。

使用xpinyin进行转换

```
name = form.cleaned_data['name']
p = Pinyin()
name_pinyin = p.get_pinyin(name)
```

- 创建项目的时候跨域要加上

```
cors_config = {
    'CORSRule': [
        {
            'AllowedOrigin': '*',
            'AllowedMethod': ['GET', 'PUT', 'HEAD', 'POST', 'DELETE'],
            'AllowedHeader': "*",
            'ExposeHeader': "*",
            'MaxAgeSeconds': 500
        }
    ]
}
```

## 文件操作的流程



- 创建项目，填写内容，post提交表单给project_list()，同时为该项目创建桶，并保存项目信息到数据库

- 打开项目的文件管理

  访问view/file.py，数据库获取项目的文件列表，并跳转file.html展示文件
  
- 文件上传

- 文件下载



### 下载文件

```
浏览器请求    django
请求         httpresponse 文本：响应头
请求		   render文本：响应头
请求     	   文件内容：响应头
```

设置响应头，如果是文件那么就下载

<img src="https://gitee.com/leoschopen/picture/raw/master/null/image-20220215100921057.png" alt="image-20220215100921057" style="zoom:50%;" />

```python
def download(request):
    with open('1.png',mode="rb") as f:
        data = f.read()
    response = HttpResponse(data)
    response['Content-Disposition'] = "attachment;filename=1.png"
    return response
```

django变量运算

```python
#加法：
{{value|add:value2}}
#返回的结果是value+value2的值，假设你value为40，value2为60 ，则该表达式
#返回结果为100

#减法
{{value|add -value2}}
#与加法的性质一样，只不过是把第二个参数变成负数进行运算，返回的结果是value-value2
#假如value=4,value2=8,则返回的结果是-4

#乘法
{% widthratio value1 value2 value3%}
#上面的代码表示 value1/value2*value3,widthratio需要三个参数，进行乘法 只需将第二个参数等于1即可
#例： value1=10 value2=1 value3=2 返回的结果为10/1*2=20

#除法
{% widthratio value1 value2 value3%}
#返回的结果是 （value1/value2）*value3  只需将value3等于1就能进行除法运算
#例： value1=100 value2=20 value3=1  返回的结果为 （100/20）*1=5
```

 

### 删除项目

删除桶，删除项目



# day15

## issues的处理流程

1. 点击issues进入到issues页面，调用view/issues,以get方式获取列表内容+分页形式代码，render到issues.html进行显示（分页形式）
2. 点击新建问题，弹出模态对话框，进行提交表格并保存到数据库的操作
3. 点击具体的项目，进入到issues_detail的页面，随之而附上的是本次点击的projectid
4. 操作记录的显示：多级嵌套，访问issuerecord通过issuedetail获取的project筛选出issuereply，并转换为json，并返回

交流问题管理

## 表结构

| ID   | 标题 | 内容 | 问题类型 | 状态 | 优先级 | 指派给 | 开始t | 结束t |
| ---- | ---- | ---- | -------- | ---- | ------ | ------ | ----- | ----- |
|      |      |      |          |      |        |        |       |       |

| id   | 问题类型   |
| ---- | ---------- |
|      | 出现的问题 |
|      |            |



| id   | 模块               |
| ---- | ------------------ |
|      | 第一期：酱油拍照   |
|      | 第二期：方便面拍照 |



新建问题：

点击弹出模态对话框

```
<a class="btn btn-success btn-sm" data-toggle="modal" data-target="#addModal">新建问题</a>


<div id="addModal" class="modal fade bs-example-modal-lg" tabindex="-1" role="dialog"
         aria-labelledby="myLargeModalLabel">
```

问题列表



## 分页功能

1. 数据获取数据

2. 显示页码

   使用pagination中的pagehtml进行页码代码生成，默认是字符串格式，如果想使用html展示，则使用safe，

   ```
   {{ page_html|safe }}
   ```

```
1. 在视图函数中
	获取分页数据
    queryset = models.Issues.objects.filter(project_id=project_id)
    page_object = Pagination(
        current_page=request.GET.get('page'),
        all_count=queryset.count(),
        base_url=request.path_info,
        query_params=request.GET
    )
    issues_object_list = queryset[page_object.start:page_object.end]

    context = {
        'issues_object_list': issues_object_list,
        'page_html': page_object.page_html()
    }
    return render(request, 'issues.html', context)拿到数据列表和分页的html代码
2. 前端对获取的数据进行显示
    {% for item in issues_object_list %}
        {{item.xxx}}
    {% endfor %}

     <nav aria-label="...">
        <ul class="pagination" style="margin-top: 0;">
            {{ page_html|safe }}
        </ul>
    </nav>
```



# day16

## 1反射

```python
xxx_object.name调用的方法
getattr(xxx_object,"name")
setattr(xxx_object,"name","leo")

request.POST
getattr(request,"POST")
```

需求：ajax发送了一个数据，{'v1':"email",'v2':"aa@qq.com"}获取到该字典后，对数据库中的用户表做一次更新

```python
def index(request):
    data_dict = json.loads(request.body.decode('utf-8'))
    user_object = ...filter
    setattr(user_object,data_dict['v1'],data_dict['v2'])
    user_object.save()
    
    return JsonResponse({"status":"成功"})
```

## **获取orm字段**

`field_object = models.UserInfo._meta_.get_field(data_dict["key"])`

field_object.verbose_name

## 可迭代对象

类中定义`__iter__`方法，且返回一个迭代器，我们根据类创建对象都是可迭代对象

```python
class Foo():
	pass

obj1=Foo()


class Bar():
    def __iter__(self):
        yield 1
        yield 2
        
obj3 = Bar()
```

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
def fab(max): 
    n, a, b = 0, 0, 1 
    while n < max: 
        yield b      # 使用 yield
        # print b 
        a, b = b, a + b 
        n = n + 1
 
for n in fab(5): 
    print n
```

第四个版本的 fab 和第一版相比，仅仅把 print b 改为了 yield b，就在保持简洁性的同时获得了 iterable 的效果。

调用第四版的 fab 和第二版的 fab 完全一致：

```
1 
1 
2 
3 
5
```

简单地讲，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。

也可以手动调用 fab(5) 的 next() 方法（因为 fab(5) 是一个 generator 对象，该对象具有 next() 方法），这样我们就可以更清楚地看到 fab 的执行流程：







是可迭代对象，就支持for循环

## 任务详细的修改更新

1. 给前端标签绑定事件触发事件发送ajax
2. 后台数据更新数据库
3. 前端要显示更新记录





# django时区语言

```
LANGUAGE_CODE = 'zh-hans'
#datetime.datetime.now() 获取UTC时间
# TIME_ZONE = 'UTC'
#datetime.datetime.now() 获取东八区时间
TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_L10N = True

#控制自动生成数据库的时间字段auto_now_add=True根据utc,false则根据timezone
USE_TZ = False
```

# 下一步任务

1. 价格策略这个删掉，只需要限制容量和大小即可，不用大动，只要默认是普通级别即可

   

2. user要加类型，任务创建者和使用众包者，在注册的时候就要说明，任务创建者显示任务详情主页，后台的类型加统计，领取任务者显示任务需求加金额，

3. 每个用户要有金额，使用网站虚拟的金额进行交易

4. 每个用户要有星级，显示在详情页中，如果是发任务的限制文件大小，空间大小，参与人数多少，如果是领取用户者则限制平台抽成。

   

5. 每个任务的模型要进行约束可参与人数的多少

6. 用户信息每次提交数据的时候标明店铺的名称和位置（需要调用百度地图之类的）

7. 使用地图展示经纬度等信息

8. 机器学习模型，根据用户的注册时长，用户等级，接单量，接单通过率，任务的难易程度，确定任务定价

7. 修改整体的文字，logo，等细节，建立起整个的任务众包平台





1. 定价方案依据常慧华论文，

   $最终价格=基础价格+0.10899*x_i+0.10899y_i+0.48519H_i+0.29682T_i$

   xi为会员聚集度，yi为任务聚集度，hi为难易程度，Ti为经济水平

2. xi，yi需要通过综合的数据计算，hi，ti为发布任务者确定，这就必须要牵扯到经纬度的获取和可视化。

   任务的二维坐标在填写的时间就进行计算并存储

1. 需要更改任务罗列方式，最好把任务放在主页
2. 将任务可视化在页面上？





## 计算会员聚集度：

1. 供求度：以任务 $i$ 为中心并确定半径 $k$, 该圆形区域内会员的数量 $x_{i}$ 以及其他 任务的数量 $y_{1}$ 构成了此任务的供求度。其中定义会员聚集度指标:
$$
\chi_{\eta}= \begin{cases}1 & d(i, j)<k \\ 0 & d(i, j)>k\end{cases}
$$
$d(i . j)$ 为任务 $i$ 和会员 $j$ 之间的距离, 则:
$$
x_{i}=\sum_{j=1}^{n_{1}} \chi_{i j}
$$
计算任务聚集度

## 计算中心位置：

使用kmeans和dbscan获取坐标的中心集群位置，将该项目归到最近的集群中作为该项目的中心点，记录在数据库中，每半个月更新一次





# 需求分析：

## 用户模块

1. 做一个用户页面展示任务的页面。当然该页面是否显示要判断是否是用户
   - 每项任务要显示价格和名称，参与人数





# 4.7

django数据库查询中的筛选，不等于的命令，使用的是exclude，不知道~q是否可以

```
all_project_list = models.Project.objects.filter().exclude(creator=request.tracer.user)
```

## 4.8日任务：

- 完成抢单按钮点下后进入文件提交页面，点击详情页面需要显示文件提交，问题反馈页面，在管理员视图中文件提交的信息栏中要加入审核

  > 超链接跳转无法实现，但是原来的页面可以实现

- 详情信息中加入距离多远

- 解决点击按钮无法跳转至页面的问题

